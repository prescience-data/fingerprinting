---
title: window.OscillatorNode
layout: default
---
# window.OscillatorNode
## Purpose
`OscillatorNode` is an interface of the Web Audio API that represents a source of a periodic waveform, such as a sine, square, sawtooth, or triangle wave. It is a fundamental `AudioNode` used for sound synthesis.

## Fingerprinting Usage
`OscillatorNode` is a cornerstone of the widely used **Audio Fingerprinting** technique. This method does not rely on user interaction or audible sound playback. Instead, it leverages an `OfflineAudioContext` to silently and rapidly render a complex audio signal generated by an `OscillatorNode` and other processing nodes.

The resulting raw audio buffer data is then hashed to produce a highly stable and unique identifier for the device.

**Sources of Entropy and Bot Detection Signals:**

1.  **Hardware and Driver Variation:** The final rendered audio samples are influenced by subtle variations in the underlying hardware (CPU, audio chipset) and the OS-level audio drivers. Different systems will produce slightly different floating-point results for the same audio processing operations.
2.  **Browser Engine Implementation:** Minor differences in how the browser's audio engine (e.g., V8's C++ implementation for Chrome) implements signal processing algorithms (like wave generation or compression) can lead to distinct outputs across different browser versions or vendors.
3.  **Anomalies in Headless Browsers:** Headless browsers (like Puppeteer/Playwright) or virtualized environments often lack a proper audio stack. When attempting to render the audio:
    *   The output buffer may be completely silent (all zeros).
    *   The process may fail or produce a constant, predictable value.
    *   These results are strong indicators of a non-standard, likely automated, environment.
4.  **Spoofing Detection:** Bots may attempt to spoof this fingerprint by overriding methods like `OfflineAudioContext.prototype.startRendering` or `AudioBuffer.prototype.getChannelData`. Anti-bot scripts can detect this by checking if these functions are native code (`Function.prototype.toString.call(method).includes('[native code]')`).

The combination of an `OscillatorNode` with a `DynamicsCompressorNode` is particularly effective, as the compressor amplifies the minute variations in the oscillator's output, creating a more entropic and reliable fingerprint.

## Sample Code
This snippet demonstrates the core logic of audio fingerprinting using an `OscillatorNode` and an `OfflineAudioContext`.

```javascript
async function getAudioFingerprint() {
  try {
    // Use OfflineAudioContext to render audio silently and quickly.
    // The specific sample rate and channel count are part of the fingerprinting setup.
    const audioCtx = new OfflineAudioContext(1, 44100, 44100);

    // Create an oscillator to generate a base signal.
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'triangle'; // The waveform type affects the output.
    oscillator.frequency.setValueAtTime(10000, audioCtx.currentTime);

    // Use a compressor to process the signal and amplify subtle variations.
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.setValueAtTime(-50, audioCtx.currentTime);
    compressor.knee.setValueAtTime(40, audioCtx.currentTime);
    compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
    compressor.attack.setValueAtTime(0, audioCtx.currentTime);
    compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

    // Connect the nodes: Oscillator -> Compressor -> Destination
    oscillator.connect(compressor);
    compressor.connect(audioCtx.destination);

    oscillator.start(0);
    const renderedBuffer = await audioCtx.startRendering();

    // Extract the raw sample data from the buffer.
    const samples = renderedBuffer.getChannelData(0);

    // Calculate a simple sum of the samples to create a hash.
    // Real-world scripts use more robust hashing algorithms like MurmurHash3.
    let hash = 0;
    for (let i = 0; i < samples.length; i++) {
      hash += Math.abs(samples[i]);
    }

    // A value of 0 is a strong indicator of a bot/headless browser.
    if (hash === 0) {
        return "BOT_DETECTED_NULL_AUDIO";
    }

    return hash.toString();
  } catch (error) {
    // Errors during audio context creation or rendering are also a signal.
    return "BOT_DETECTED_AUDIO_ERROR";
  }
}

// Usage:
getAudioFingerprint().then(fingerprint => {
  console.log('Audio Fingerprint:', fingerprint);
});
```