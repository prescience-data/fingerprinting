---
title: window.Audio
layout: default
---
# window.Audio
## Purpose
The `window.Audio` constructor creates and returns a new `HTMLAudioElement` object. This object is used to programmatically embed and control audio content within a web document, typically for playing sound files.

## Fingerprinting Usage
The `HTMLAudioElement` interface is a significant source of entropy for browser fingerprinting and a key component in bot detection.

1.  **Codec Support (`canPlayType`)**: This is the primary fingerprinting vector. Browsers, operating systems, and even hardware (via hardware-accelerated decoding) support different sets of audio containers (e.g., MP4, Ogg, WAV) and codecs (e.g., AAC, MP3, Opus, Vorbis, FLAC). The `canPlayType()` method returns `"probably"`, `"maybe"`, or an empty string (`""`) for a given MIME type. The combination of results for a list of codecs creates a highly specific fingerprint. For example, Safari on iOS supports ALAC, while Chrome on Android does not.

2.  **Behavioral and Performance Anomalies**: Headless browsers (like Puppeteer or Playwright) and other botting frameworks often lack a real audio output device or use audio shims. This creates detectable inconsistencies:
    *   **Event Timing**: Events like `canplay` or `canplaythrough` may fire suspiciously quickly, as there is no real network buffering or hardware decoding buffer to fill. A script can measure the time between setting the `src` and the firing of these events.
    *   **Duration Property**: For a remote audio source, a real browser must download at least part of the file to read its metadata and determine the `duration`. A headless browser might report a duration of `0` or `Infinity`, or report the correct duration instantly, which is unnatural.
    *   **`played` Property**: The `played` property returns a `TimeRanges` object. In many headless environments, this object may not update correctly or at all when `play()` is called, as no audio is actually being processed by an audio sink.

3.  **Error Handling**: The specific error codes and messages generated by the `MediaError` object when attempting to play a malformed or unsupported audio file can differ between browser engines (Blink, Gecko, WebKit) and versions. This provides an additional data point for identifying the underlying platform.

4.  **Default Property Values**: Automation tools may launch browsers with specific flags, such as `--mute-audio`. This can cause properties like `muted` to be `true` by default or `volume` to be `0`, which is atypical for a standard user session and can be used as a bot signal.

## Sample Code
This snippet demonstrates fingerprinting using the `canPlayType` method to generate a fingerprint based on audio codec support.

```javascript
async function getAudioFingerprint() {
  try {
    const audio = new Audio();
    const codecsToTest = [
      // Common formats
      'audio/ogg; codecs="vorbis"',
      'audio/mpeg',
      'audio/wav; codecs="1"',
      'audio/mp4; codecs="mp4a.40.2"',
      // Less common / newer formats
      'audio/webm; codecs="opus"',
      'audio/flac',
    ];

    const supportSignature = codecsToTest.map(codec => {
      const supportLevel = audio.canPlayType(codec);
      // Map results to a compact representation
      if (supportLevel === 'probably') return 'p';
      if (supportLevel === 'maybe') return 'm';
      return 'n'; // 'n' for no support
    }).join('');

    // Example output: "pmnpyn"
    return supportSignature;
  } catch (e) {
    // If Audio constructor is blocked or fails
    return 'error';
  }
}

// Usage:
getAudioFingerprint().then(fingerprint => {
  console.log('Audio Codec Fingerprint:', fingerprint);
});
```