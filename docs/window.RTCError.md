---
title: window.RTCError
layout: default
---
# window.RTCError
## Purpose
The `RTCError` interface represents an error that occurs during the processing of WebRTC (Web Real-Time Communication). It extends the `DOMException` interface, providing specific details about failures in WebRTC operations like session establishment or data channel creation.

## Fingerprinting Usage
While not a primary fingerprinting vector on its own, `RTCError` is a powerful tool for environment probing and anomaly detection. Its utility comes from analyzing the errors generated by intentionally flawed WebRTC calls.

1.  **Environment Probing**: Anti-bot systems can execute WebRTC operations that are known to fail in specific ways on standard browsers. Headless browsers (like older Puppeteer/Playwright versions) or modified browser environments often have incomplete or stubbed WebRTC implementations. An attempt to use WebRTC might:
    *   Throw a generic `TypeError` instead of an `RTCError` if the constructor is missing.
    *   Throw an `RTCError` with a message that is inconsistent with genuine browsers.
    *   Fail to throw an error at all, indicating a non-functional stub.
    This makes `RTCError` a key signal for detecting headless automation.

2.  **Error Message Variance**: The exact string in the `message` property of a thrown `RTCError` can vary between browser vendors (Chrome, Firefox), versions, and even operating systems for the same underlying issue. This provides a source of entropy that helps fingerprint the browser build. For example, the error for an invalid `createOffer` option might be worded slightly differently in Chrome 105 vs. Chrome 115.

3.  **Stack Trace Analysis**: The `stack` property of the error object is a high-entropy signal. The call stack reveals the execution path leading to the error. In automated environments, the stack trace may contain artifacts from the automation driver (e.g., Puppeteer's internal functions) or appear unusually short or structured, betraying its non-human origin.

4.  **Spoofing Inconsistency**: A bot may spoof its User-Agent string to appear as "Chrome on Windows" but use a Linux-based automation tool. The WebRTC implementation, and thus the resulting `RTCError` messages and stack traces, will likely correspond to the underlying Linux Chromium build, creating a detectable inconsistency.

## Sample Code
This snippet intentionally triggers a WebRTC error to analyze the resulting error object. A bot or modified browser may produce a different result than a standard Chrome browser.

```javascript
async function probeRtcError() {
  const signals = {
    errorType: 'N/A',
    errorMessage: 'N/A',
    isRtcError: false,
    stackHash: 'N/A'
  };

  try {
    const pc = new RTCPeerConnection();
    // Intentionally use an invalid argument to force an error.
    // A standard browser will throw a specific RTCError.
    await pc.createOffer({ 'offerToReceiveVideo': 'invalid' });
  } catch (e) {
    signals.errorType = e.name; // e.g., 'TypeError', 'OperationError'
    signals.errorMessage = e.message;
    signals.isRtcError = e instanceof RTCError;

    // The stack trace is a high-entropy signal. Hashing is common.
    if (e.stack) {
      // In a real scenario, a more robust hashing function would be used.
      signals.stackHash = btoa(e.stack); 
    }
  }

  // Analyze the signals:
  // - A genuine Chrome browser will set isRtcError to true.
  // - The errorMessage will be consistent for a given Chrome version.
  // - The stackHash will be different in an automation context.
  console.log(signals);
  return signals;
}

probeRtcError();
```